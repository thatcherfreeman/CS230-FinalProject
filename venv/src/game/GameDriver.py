from typing import List, Tuple

from game.piece.TetrisPiece import TetrisPiece
from game.Direction import Direction
from game.GameState import GameState, PIECE_QUEUE_LEN, PLAYFIELD_WIDTH, PLAYFIELD_HEIGHT, BUFFER_HEIGHT
from game.PieceGenerator import PieceGenerator

# the value at each index is the score reward for clearing (index + 1) lines. This system is from level 1 of the
# popular Nintendo Game Boy version.
CLEAR_POINTS = [40, 100, 300, 1200]
# TODO: Check for loss when generating a new piece


def getClearPoints(numRowsCleared: int):
    return CLEAR_POINTS[numRowsCleared - 1]


class GameDriver:
    """A class containing a tetris game state as well as being able to update the state in response to player actions.
    This class contains all of the game logic for Tetris."""
    def __init__(self):
        self.state = GameState()
        self.pieceGenerator = PieceGenerator()
        self.initGameState()

    def setCurrentPiece(self, piece: TetrisPiece):
        self.state.currentPiece = piece

    def setCurrentPieceLocation(self, location: Tuple[int, int]):
        self.state.currentPieceLocation = location

    def setQueuedPieces(self, pieces: List[TetrisPiece]):
        self.state.pieceQueue = pieces

    def initGameState(self):
        self.setCurrentPiece(self.pieceGenerator.generatePiece())
        self.setCurrentPieceLocation((PLAYFIELD_WIDTH/2, PLAYFIELD_HEIGHT))
        self.setQueuedPieces([self.pieceGenerator.generatePiece() for i in range(0, PIECE_QUEUE_LEN)])

    # Returns whether or not this causes the end of the game
    def rotatePiece(self, clockwise: bool):
        # TODO: collision checks and wall kicks
        piece = self.state.currentPiece
        if clockwise:
            piece.rotateCW()
        else:
            piece.rotateCCW()
        pass

    # Returns whether or not this causes the end of the game
    def movePiece(self, direction: Direction):
        collision = self.checkCollision(direction.deltaX, direction.deltaY)

        location = self.state.currentPieceLocation
        if not collision:
            centerX = location[0]
            centerY = location[1]
            deltaX = direction.deltaX
            deltaY = direction.deltaY
            location = (centerX + deltaX, centerY + deltaY)

        return self.finalizePieceChange(location)

    def checkCollision(self, deltaX, deltaY):
        piece = self.state.currentPiece
        location = self.state.currentPieceLocation
        centerX = location[0]
        centerY = location[1]
        collision = False
        for x in range(-2, 2):
            for y in range(-2, 2):
                pieceOccupies = piece.overlay.get(x, y)
                boardOccupies = self.isBoardSpaceOccupied(x + centerX + deltaX, y + centerY + deltaY)
                collision = collision or (pieceOccupies and boardOccupies)
        return collision

    # call this after changing (or not) the location of the piece. Return true if and only if the piece has been placed.
    def finalizePieceChange(self, location: Tuple[int, int]):
        self.setCurrentPieceLocation(location)
        piece = self.state.currentPiece
        centerX = location[0]
        centerY = location[1]
        for x in range(-2, 2):
            for y in range(-2, 2):
                if piece.overlay.get(x, y) and self.isBoardSpaceOccupied(x + centerX, y + centerY - 1):
                    return True
        return False

    def placePiece(self):
        piece = self.state.currentPiece
        centerX = self.state.currentPieceLocation[0]
        centerY = self.state.currentPieceLocation[1]
        for x in range(-2, 2):
            for y in range(-2, 2):
                if piece.overlay.get(x + centerX, y + centerY):
                    self.state.overlay.set(x + centerX, y + centerY, True)

    def checkAndClearLines(self):
        """Returns point value generated by clears"""
        piece = self.state.currentPiece
        centerY = self.state.currentPieceLocation[1]
        rowsToClear = []
        # Find each row the piece occupies
        for y in range(-2, 2):
            for x in range(-2, 2):
                if piece.overlay.get(x, y):
                    if self.isRowFull(y + centerY):
                        rowsToClear.append(y + centerY)
                    break
        return self.clearLines(rowsToClear)

    def isRowFull(self, y: int):
        overlay = self.state.overlay
        for x in range(0, PLAYFIELD_WIDTH):
            if not self.state.overlay.get(x, y):
                return False
        return True

    def clearLines(self, rowsToClear: List[int]):
        """Returns point value generated by clears"""
        if len(rowsToClear) == 0:
            return

        clearParamsList = []
        # (bottom of block that needs to be shifted down, top of block that needs to be shifted
        # down (inclusive), rows to shift by)
        curClearParams = None
        for i in range(0, len(rowsToClear)):
            rowNum = rowsToClear[i]
            if curClearParams is not None:
                if curClearParams[0] == rowNum:
                    curClearParams[0] = rowNum + 1
                    curClearParams[2] = i + 1
                else:
                    curClearParams[1] = rowNum - 1
                    clearParamsList.append(curClearParams)
                    curClearParams = [rowNum + 1, PLAYFIELD_HEIGHT, i + 1]
            else:
                curClearParams = [rowNum + 1, PLAYFIELD_HEIGHT, i + 1]
        clearParamsList.append(curClearParams)
        rowsCleared = 0
        points = 0
        for clearParams in clearParamsList:
            # Clearing multiple non-contiguous rows is not worth as much as clearing the same number of contiguous rows
            points += getClearPoints(clearParams[2] - rowsCleared)
            rowsCleared += clearParams[2]
            self.clearBlock(clearParams[0], clearParams[1], clearParams[2])
        return points

    def clearBlock(self, bottomRowToShift: int, topRowToShift: int, rowsToShift: int):
        overlay = self.state.overlay
        for row in range(bottomRowToShift, topRowToShift + 1):
            for x in range(0, PLAYFIELD_WIDTH):
                overlay.set(x, row - rowsToShift, overlay.get(x, row))

    def isBoardSpaceOccupied(self, x: int, y: int):
        if x < 0 or y < 0 or x >= PLAYFIELD_WIDTH or y >= (PLAYFIELD_HEIGHT + BUFFER_HEIGHT):
            return True
        return self.state.overlay.get(x, y)